
[[SOLID Principles#3. L (Liskov Substitution Principle)]]

# Khái niệm

 *Khi mở rộng một class, hãy nhớ rằng bạn sẽ có thể truyền các objects của subclass thay cho các objects của superclass mà không phá vỡ client code*

- Nguyên tắc thay thế là một tập hợp các kiểm tra giúp dự đoán liệu một subclass có còn tương thích với code có thể làm việc với các objects của superclass hay không

- Khi bạn developing các libraries hoặc framework, việc này trở nên vô cùng quan trọng. Bạn không thể kiểm soát source code của người khác, nhưng bạn muốn đảm bảo rằng các classes của bạn có thể được sử dụng một cách đáng tin cậy và dễ dàng mà không làm hỏng mã của họ.

	-  Bằng cách tuân thủ nguyên tắc này, bạn đảm bảo rằng khi một object của subclass được chuyển vào thay thế một object của superclass trong source code hiện tại, không có hành vi hoặc tính năng nào sẽ bị hỏng hoặc thay đổi. Điều này giúp cho việc mở rộng và maintain code trở nên dễ dàng hơn, đồng thời tăng tính linh hoạt của code.


# Tập hợp các requirements for subclass


### Các params trong một method của một subclass phải khớp hoặc trừu tượng hơn các params trong method của superclass


***Good...***
```ts
// superclass
class Cat {
  feed(cat: Cat) {
    console.log("Feeding cat");
  }
}

// subclass
class Animal extends Cat {
  feed(animal: Animal) {
    console.log("Feeding animal");
  }
}
=> class Animal với method feed() có thể cho bất cứ động vật nào ăn, context được mở rộng ra
```


***Bad...***
```ts
// superclass
class Cat {
  feed(cat: Cat) {
    console.log("Feeding cat");
  }
}

// subclass
class BenganCat extends Cat {
  feed(benganCat) {
    console.log("Feeding BenganCat");
  }
}

=> class BenganCat với method feed() chỉ dành cho loại mèo Bengan, nếu truyền loại mèo khác hoặc loại động vật khác vào sẽ lỗi, context bị thu hẹp
```

