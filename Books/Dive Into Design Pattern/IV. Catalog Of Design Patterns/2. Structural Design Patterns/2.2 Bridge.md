![[oop-78.png]]

# Khái niệm

***Bridge is a structural design pattern that lets you split a large class or a set of closely related classes into two separate hierarchies—abstraction and implementation—which can be developed independently of each other.***

- Bridge là một mẫu thiết kế cấu trúc cho phép chia một class lớn hoặc một tập hợp các classes liên quan chặt chẽ thành hai hệ thống phân cấp riêng biệt - abstract và implemenmt  - có thể được phát triển độc lập với nhau

# Problem

- Giả sử có một class hình học là `Shape` với một cặp subclass là: `Circle` and `Square`
	- Muốn extend hệ thống phân cấp class này để kết hợp thêm colors, nên sẽ tạo thêm 2 subclass `Red` & `Blue`
	- Tuy nhiên, giờ ta cần tạo bốn class combinations như `BlueCircle` & `RedSquare`

![[oop-79.png]]


- Việc thêm mới shape types & colors vào cấu trúc phân cấp(hierarchy) sẽ làm nó phát triển theo cấp số nhân

# Solution

- Sự cố trên xảy ra do ta cố gắng extend shape classes trong hai chiều độc lập: theo form & color 
	- Đó là issue rất phổ biến với class inheritance
	
- Bridge pattern cố gắng giải quyết vấn đề này bằng cách chuyển từ inheritance => composition
	- Nghĩa là trích xuất một trong các dimensions vào một class hierarchy riêng biệt
	- Các original class sẽ tham chiếu đến một object của new hierarchy, thay vì để tất cả state & behaviors trong một class

![[oop-80.png]]


- Theo cách tiếp cận này, chúng ta có thể tách code liên quan tới color thành class riêng với 2 subclasses : `Red` & `Blue`
	- Shape class sau đó nhận được 1 reference field trỏ đến một trong các color objects
	- => Shape có thể ủy thác bất kỳ công việc liên quan đến color bất kỳ cho color object được liên kết
	- Tham chiếu này hoạt động như một bridge giữa `Shape` & `Color` classes 
	- => Giờ thì add thêm new color không cần phải thay đổi shape hierarchy và ngược lại

## Abstraction and Implementation

- Abstract (interface) là một high-level control layer cho một số entity
	- Layer này không được phép tự mình thực hiện bất kỳ công việc thực sự nào, mà nó ủy thác công việc cho implementation layer (platform)
	
* Lưu ý rằng khái niệm này không nói về interface or abstract class trong programming language

- Khi nói về các App trong thực tế, abstraction có thể được represented bởi một graphical user inteface(GUI), và implementation được gọi là operating system code(API) mà GUI layer calls để response các tương tác của user

- Nói chung, có thể extend App theo 2 hướng độc lập:
	- Có một vài GUI khác nhau(Trang admin, trang bán hàng, ...)
	- Hỗ trợ một vài APIs khác nhau (...)

![[oop-81.png]]

- Ta có thể mang lại trật tự cho sự hỗn loạn này bằng cách trích xuất related code đến interface-platform combinations cụ thể thành các classes riêng biệt
	- Tuy nhiên class hierarchy sẽ phát triển theo cấp số nhân vì thêm new GUI hoặc supporting một API khác sẽ yêu cầu tạo ngày càng nhiều classes

- Hãy thử solve issue này với Bridge pattern, chia classes thành hai hierarchies:
	- Abstraction: GUI layer của App
	- Implementation: operating system's APIs
	
	![[oop-82.png]]

- Abstract object controls sự xuất hiện của App, ủy thác real work cho implement object được liên kết
	- Các implementations có thể hoán đổi cho nhau miễn là chúng follow cùng một common interface, cho phép cùng một GUI work với Windows & Linux
	
- Kết quả là ta có thể change GUI classes mà không cần chạm vào API-related classes. 
	- Hơn nữa, nếu adding support cho operating system khác chỉ yêu cầu tạo một subclass trong implementation hierarchy

# Structure

![[oop-83.png]]

- 1. Abstraction cung cấp high-level control logic
	- Nó dựa vào các implementation object để thực hiện công việc low-level thực tế
	
- 2. Implementation declares common interface cho tất cả các concrete implementations
	- Một abstraction có thể chỉ giao tiếp với một implementation object thông qua methods được declared ở đây
	
	- Abstraction có thể list các methods tương tự như implementation
		- Nhưng thông thường abstraction declares một số complex behaviors dựa trên nhiều hoạt động nguyên thủy(primitive) được declares bởi implementation































