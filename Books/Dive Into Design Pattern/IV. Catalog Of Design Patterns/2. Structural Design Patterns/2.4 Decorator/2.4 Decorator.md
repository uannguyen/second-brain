![[oop-91.png]]

# Khái niệm

***Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors***

- Decorator là mẫu thiết kế cấu trúc cho phép bạn đính kèm các hành vi mới vào các đối tượng bằng cách đặt các đối tượng này bên trong các đối tượng bao bọc đặc biệt có chứa các hành vi

# Problem

- Hãy tưởng tượng ta đang working trên một notification library cho phép các program khác notify cho users của họ về các events quan trọng

- Initial version của library based on `Notifer` class chỉ có một vài fields, một constructor và một method `send`
	- Method `send` này có thể accept một đối số `message` từ client và send message đến list emails cần gửi
	- Một 3rd-party hoạt động như một client được cho là tạo ra & configure notificator object một lần, và sau đó dùng nó mỗi khi có điều gì đó quan trọng xảy ra
	
	![[oop-92.png]]

- Sau đó, loại thông báo qua email này chưa đáp ứng đủ mong đợi của users
	- Và thế là các kênh bắn notify khác được apply zô: SMS, Facebook, Slack, ...

![[oop-93.png]]

- Điều đó khó như nào ?
	- Extended `Notifer` class & thêm notifaction methods vào new subclasses
	- Bây giờ client coi như đã khởi tạo & sử dụng cho tất cả các notifications tiếp theo
	
- Sau đó, một câu hỏi được đặt ra: Tại sao không thể dùng nhiều loại noti cùng một lúc ?

![[oop-94.png]]

- Cố gắng giải quyết problem bằng cách tạo special subclass gom nhiều notifications methods trong cùng một class
	-  Tuy nhiên, cách này sẽ làm code phình to vô cùng, không chỉ library code mà client code cũng vậy
	

# Solution

## 1. Hạn chế của inheritance

- Khi cần thay đổi object's bahavior, ta thường extending class. Tuy nhiên, inheritance có một số cảnh báo nghiệm trọng cần lưu ý:
	- Inheritance là static. Không thể thay đổi behavior của object hiện có runtime
		- Bạn chỉ có thể thay thế toàn bộ object bằng một object khác được tạo từ subclass khác
	- Subclass chỉ có thể inheritance từ một superclass (trong hầu hết các programming languages)

## 2. Dùng Composition thay vì Inheritance

- Một trong những cách khắc phục là có thẻ dùng `Composition` thay vì `Inheritance` 
	- Với composition, một object reference tới object khác và ủy thác some work, kế thừa behavior từ superclass

- Composition có thể dễ dàng thay thế "helper" object bằng một object khác, changing behavior của container runtime
	 - Một object có thể dùng behavior của các classes khác nhau, có references đến multiple objects và ủy thác chúng cho tất cả các loại công việc

- Composition là key principle đằng sau nhiều design patterns, including Decorator

![[oop-95.png]]

## Wrapper pattern

- Wrapper là nickname thay thế cho Decorator pattern thể hiện rõ main idea của pattern
	- Một wrapper là một object có thể được link với một số "target" object
	- Wrapper chứa cùng một tập hợp methods như "target" và ủy thác tất cả requests mà nó nhận được
	- Tuy nhiên, wrapper có thể thay đổi result bằng cách làm điều gì đó trước hoặc sau khi request đến target

## Wrapper trở thành Decorator
- Khi nào simple wrapper trở thành real decorator ?
	- Wrapper implements cùng một interface như wrapped object
	- Làm cho wrapper's reference field chấp nhận bất kỳ object nào follows interface đó
	- Điều này cho phép cover một object trong multiple wrappers, adding combined behavior của tất cả các wrapper vào nó

![[oop-96.png]]

