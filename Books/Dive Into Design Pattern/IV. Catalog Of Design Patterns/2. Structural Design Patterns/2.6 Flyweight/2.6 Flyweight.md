
# Concept

***Flyweight is a structural design pattern that lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object***

- Flyweight là một mẫu thiết kế cấu trúc được sử dụng để tối ưu hóa việc sử dụng bộ nhớ(RAM) bằng cách chia sẽ các phần chung của `state` giữa các objects với nhau thay vì giữ tất cả `data` trong mỗi object

# Problem

- Tạo một simple video game bắn súng:
	- Kiểu như PUBG
	- Apply hệ thống hạt (particle system) thực tế để biến nó thành một feature đặc biệt
		- Particle system trong trò chơi dùng để tạo các hiệu ứng hình ảnh động cho các sự kiện như súng đạn, tên lửa, ...
	- Một lượng lớn đạn, tên lửa và mảnh đạn từ các vụ nổ sẽ bay khắp bản đồ và mang đến trải nghiệm ly kỳ cho player
- Sau khi game hoàn thành, bạn built game & gửi cho bạn bè cùng chơi
	- Tuy nhiên, khi họ chơi được vài phút thì lại bị crashing mặc dù máy bạn chơi vẫn ổn
- Lỗi xảy ra do máy thiếu RAM, và do máy bạn cấu hình mạnh hơn máy của your friend nên chưa bị sao

![[oop-106.png]]

- Vấn đề thực tế liên quan đến particle system 
	- Mỗi particle, chẳng hạn như một viên đạn, một tên lửa hoặc một mảnh đạn được represented bới một vật thể riêng biệt chứa nhiều data
	- Khi đến khúc combat cao trào thì các particle mới được tạo ra vượt quá với RAM còn lại, nên game bị cashed

# Solution

- Khi check lại `Particle` class, bạn nhận thấy các fields `color` & `sprite` tiêu tốn nhiều memory hơn các fields khác
	- Cay hơn là 2 fields này lưu trữ data gần như giống hệt nhau trên tất cả các particles
	- Ex: tất cả các viên đạn có cùng color & sprite
	
![[oop-107.png]]

- Các phần khác của particle's state, chẳng hạn như coordinates, movement vevtor & speed là unique cho mỗi particle
	- Value của các fields này thay đổi theo thời gian trong khi color & sprite không đổi cho mỗi particle

- Constant data của một object called `intrinsic state`, nằm trong object & only read , không thể change
- Phần còn lại của state thường bị change bởi các object khác, called `extrinsic state`
- Khi apply flyweight pattern, `intrinsic state` sẽ được giữ lại bên trong objects, trong khi `extrinsic state` sẽ được truyền từ bên ngoài thông qua các methods cụ thể...
- Điều này giúp tối ưu hóa memory bằng cách chỉ lưu constant data 1 lần duy nhất & reuse trong các context khác nhau

![[oop-108.png]]

- Như vậy, ta chỉ cần ít các objects này hơn vì chúng chỉ khác nhau ở `intrinsic state`, trong đó ít biến thể hơn nhiều so với `extrinsic state`

- Trở lại với game, giả sử chúng ta đã trích xuất extrinsic state từ particle class, và chỉ có 3 objects khác nhau đủ để represent tất cả các particles trong game: một viên đạn, một tên lửa & một mảnh đạn
	- Một object chỉ lưu trữ intrinsic state được gọi là flyweight

## Extrinsic state storage

- Extrinsic state nằm ở đâu ?
	- Đa số được move đến container object, là object tổng hợp các đối tượng trước khi apply design pattern
- Trong case Game này, main `Game` object lưu trữ tất cả các particles trong `particles` field 
	- Để move extrinsic state vào class này, ta cần tạo một số array fields để lưu trữ coordinates, vectors & speed của mỗi particle riêng lẻ
	- Chưa hết, ta còn cần một array khác để lưu references đến một flyweight cụ thể đại diện cho một particle - Các array này phải được sync với nhau để có thể truy cập tất cả các particle với cùng một index

![[oop-109.png]]

- 1 solution khác là tạo ra một context class riêng biệt sẽ lưu trữ extrinsic state cùng với reference đến flyweight object
	- Cách này yêu cầu chỉ có một single array duy nhất trong container class(lớp ngoài cùng)

- Giờ thì chúng ta có cần phải có nhiều contextual objects như lúc đầu không ?
	- Vẫn có nhe, nhưng những objects này sẽ nhỏ hơn nhiều so với trước
	- Các fields tiêu tốn memory nhất đã bị moved vào flyweight objects
	- Now, cả ngàn small contextual objects có thể tái sử dụng lại một flyweight nặng một cách hiệu quả thay vì lưu trữ cả ngàn bản copy 

# Flyweight and immutability

- Cùng một flyweight có thể được dùng trong nhiều contexts khác nhau nên phải đảm bảo state của nó không được modified
	- State chỉ nên được initialize một lần via constructor parameters
	- Không nên để lộ bất kỳ setters hoặc public fields cho các objects khác

# Flyweight factory

- Để truy cập các flyweights khác nhau tiện hơn, ta có thể tạo một factory method để manages một nhóm các flyweight objects hiện có
	
	- Factory method nhận vào intrinsic state của flyweight mà client mong muốn, tìm flyweight object matching với state này
	- Returns nếu tìm thấy, và tạo mới nếu ko tìm thấy
	- Kiểu như có một field(Object) lưu các flyweights dạng key: value, key là cái client truyền vào để get value là flyweight ra

- Có một số options về địa điểm đặt của method này như:
	- Rõ ràng nhất là một container flyweight
	- Ngoài ra có thể tạo new factory class
	- Hoặc có thể làm factory method thành dạng static & đặt nó inside một flyweight class thực tế

# Structure

![[oop-110.png]]

- 1. Flyweight đơn thuần chỉ là optimization
	- Trước khi applying, cần check xem program có vấn đề về tiêu tốn lượng lớn RAM cho các objects tương tự kh
	- Và chắc chắn rằng vấn đề này không thể solved theo bất kỳ cách có ý nghĩa nào khác
	
- 2. 