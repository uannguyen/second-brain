![[Pasted image 20240318133139.png]]
# Khái niệm

- Cung cấp một interface để tạo các đối tượng trong một superclass nhưng cho phép subclass thay đổi loại đối tượng sẽ được tạo

- Điều này giúp tăng tính flexibility của code và giảm sự phụ thuộc vào class cụ thể. Factory Method thường được sử dụng trong các hệ thống mà các objects cụ thể cần được tạo ra theo conditions hoặc dynamic info từ user hoặc từ các phần khác của system

# 🙁 Problem 


![[oop-30.png]]

- Giả sử có 1 app quản lý hậu cần
- First version app chỉ có thể xử lý vận chuyển bằng xe tải
	=> Phần lớn code đều nằm trong Truck class
	
- Sau 1 thời gian, App trở nên phổ biến
	+ Mỗi ngày có hàng chục requests y/c từ các Sea transportation companies để kết hợp sea logistics vào App
	
- Giờ đây, hầu hết code đều được ghép nối với Truck class. 
	=> Add Ships vào app sẽ y/c thay đổi toàn bộ codebase. 
	=> Hơn nữa, nếu sau này thêm bất kỳ 1 loại transportation nào vào app, sẽ cần phải thực hiện lại tất cả những thay đổi này
	
--- 
Cuối cùng là sml => dẫn đến việc mã trở nên lộn xộn với các điều kiện rẽ nhánh kiểm tra loại đối tượng vận tải để xác định hành vi của ứng dụng
	
# Solution

- Thay thế các cuộc gọi xây dựng đối tượng trực tiếp (sử dụng toán tử `new`) bằng các cuộc gọi đến một `special factory method`

- Các đối tượng vẫn được tạo thông qua toán tử mới, Nhưng nó được gọi từ bên trong factory method

- Các objects được returned bằng factory method thường được gọi là "products".
	
	![[oop-31.png]]

- Thoạt nhìn, thay đổi này có vẻ vô nghĩa, just moved constructor call từ phần này sang phần khác của program.
	- Tuy nhiên, giờ ta có thể override factory method trong 1 subclass và thay đổi products class được tạo ra từ method

- Có 1 hạn chế nhỏ:
	+ subclass chỉ return về các loại products khác nhau nếu các products có base class hoặc interface chung
	+ Ngoài ra, factory method trong base class phải có return type là interface này 

![[oop-32.png]]	
	
	
- Cả 2 classes `Truck` & `Ship` nên implement `Transport` interface, trong đó declares 1 method là `deliver()`

- Mỗi class implement method này khác nhau:
	+ `Truck` vận chuyển bằng đường bộ
	+ `Ship` vận chuyển bằng đường thủy
	
- Factory method trong `ReadLogistics` class returns về các objects `truck`, factory method trong SeaLogistics class returns về `ships` objects

- Code sử dụng factory method(client code) không có sự khác biệt giữa các products thực tế được returns về bởi các subclass khác nhau
- Client coi tất cả các products như là abstract `Transport`

![[oop-33.png]]


# Structure

	![[oop-34.png]]

- 1. `Product` declares interface, chung cho tất cả các objects có thể được tạo bởi creator và các subclasses của nó
- 2. `Concrete Product` là các implement khác nhau của `Product` interface
- 3. Class `Creator` declares factory method returns về các objects sản phẩm mới. Điều quan trọng là return type của method này phải khớp với `Product` interface
	- Bạn có declares factory method là abstract để buộc tất cả các lớp csubclasses implement các phiên bản riêng của method
	- Thay vào đó, base factory methodcó thể trả về một số loại product mặc định.

	- việc tạo ra product không phải là trách nhiệm chính của creator

	- Thông thường, class creator có 1 số core business login liên quan đến products
	
	- Factory method giúp tách login này khỏi các Concrete product class
	
	- VD: 1 company phát triển phần mềm lớn có thể có bộ phận training riêng cho lập trình viên, tuy nhiên chức năng chính của company là viết mã, ko phải sản xuất Programmers.


# Code Example

```ts

// Interface cho các phương tiện vận chuyển
interface Transport {
  deliver(): string;
}

// Lớp cụ thể đại diện cho xe tải
class Truck implements Transport {
  deliver(): string {
    return 'Delivering cargo by land';
  }
}

// Lớp cụ thể đại diện cho tàu biển
class Ship implements Transport {
  deliver(): string {
    return 'Delivering cargo by sea';
  }
}

// Logistics cơ sở đại diện cho loại vận chuyển chung
abstract class Logistics {
  abstract createTransport(): Transport;

  // Factory method
  planDelivery(): string {
    const transport = this.createTransport();
    return transport.deliver();
  }
}

// Logistics đường bộ triển khai factory method trả về xe tải
class RoadLogistics extends Logistics {
  createTransport(): Transport {
    return new Truck();
  }
}

// Logistics đường biển triển khai factory method trả về tàu biển
class SeaLogistics extends Logistics {
  createTransport(): Transport {
    return new Ship();
  }
}

// Client code
function clientCode(logistics: Logistics) {
  console.log(logistics.planDelivery());
}

// Sử dụng Factory Method Pattern
const roadLogistics = new RoadLogistics();
clientCode(roadLogistics); // Output: Delivering cargo by land

const seaLogistics = new SeaLogistics();
clientCode(seaLogistics); // Output: Delivering cargo by sea

```
	
	