![[oop-146.png]]


# Concept

***Iterator is a behavioral design pattern that lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.).***

- Là pattern loop tuần tự qua các phần tử của một collection mà không làm ảnh hưởng để lộ biểu diễn cơ bản của nó(list, stack, tree, ...) 

# Problem

![[oop-147.png]]

- Hầu hết collections lưu trữ elements dạng simple lists
	- Tuy nhiên, còn một số cấu trúc phức tạp khác như stacks, trees, graphs, ..
- Dù lưu kiểu gì thì cũng cần một cách để go through từng element của collection mà không accessing same elements nhiều lần
- Nếu code func duyệt collection vào các collections class  có thể làm lu mờ đi responsibility của nó và có thể bị duplicated code, chưa kể một số element class còn có thể có algorithms riêng biệt, ...
- Client code work với collections khác nhau thậm chí không care cách store elements
	- Mỗi collections có thể có cách khác nhau để accessing elements, nên không có cách nào khác ngoài việc couple code với collections classes cụ thể


# Solution

- Tách func xử lý loop elements của collection thành một object riêng called *iterator* 
- Ngoài việc tự implementing algorithm, iterator object encapsulates tất cả chi tiết traversal(duyệt qua): current position, còn bao nhiêu elements, ...
- Do là đối tượng độc lập, iterator có thể apply cho nhiều collections cùng lúc 

![[oop-148.png]]

- Thường thì iterators cung cấp một primary method fetching elements từ colection
	- Client có thể running method này cho đến khi không còn element nào nữa

- All iterators nên implement cùng một interface 
	- Nếu cần tạo một cách đặc biệt để duyệt qua collection, chỉ cần tạo new iterator class mà không cần thay đổi code client & collection

# Real-World Analogy

![[oop-149.png]]


		