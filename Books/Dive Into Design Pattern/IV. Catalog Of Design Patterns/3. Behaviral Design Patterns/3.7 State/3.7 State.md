
![[oop-174.png]]

# Concept

***State is a behavioral design pattern that lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.***

- State là mẫu thiết kế hành vi cho phép một object thay đổi behavior của nó khi state thay đổi. Nó xuất hiện như thể object đã thay đổi class của nó

# Problem

- State pattern có liên quan chặt chẽ đến concept **Finite-State Machine**

![[oop-175.png]]

- Ý tưởng chính là tại bất kỳ một thời điểm nào, chỉ có một số lượng hữu hạn states mà một program có thể có
	- Trong bất kì unique state, the program hoạt động khác nhau và có thể switched từ state sang state khác ngay lập tức
	- Tuy nhiên, tùy thuộc vào current state mà program có thể hoặc không thể switch sang state khác
	- Các quy tắc switching này called `transitions`, cũng hữu hạn(finite) và được xác định trước(predetermined)

- Ta cũng có thể apply phương pháp này cho objects
	- Giả sử có `Document` class, document có 3 states: `Draft`, `Moderation` and `Published`
	- The `publish` method của document works hơi khác nhau một chút ở mỗi state:
		- `Draft` sẽ moves the document to moderation
		- `Moderation` sẽ makes the document public, nhưng chỉ khi current user là adminstrator
		- `Published` sẽ không làm gì cả

![[oop-176.png]]

- State machines thường implemented với nhiều conditional operators (`if` or `switch`) để select behavior thích hợp tùy thuộc vào current state
	- Thường thì "state" chỉ là một tập hợp values của object's fields

- Nhược điểm lớn nhất của state machine dựa trên các conditionals là khi thêm nhiều states và behaviors xử lý tương ứng với states đó
	- Gây khó maintain bởi vì bất kì thay đổi nào với transition logic sẽ buộc phải thay đổi state conditionals ở mỗi method
	
- Vấn đề trở nên lớn hơn khi project ngày càng phát triển
	- Khá khó để dự đoán tất cả states & transitions ở giai đoạn đầu
	- Do đó, nó sẽ phát triển thành một mớ hỗn độn cồng kềnh theo thời gian

# Solution

- State pattern đề nghị với mỗi state cần tạo class tương ứng & trích xuất tất cả behaviors liên quan vào class này

- Thay vì implementing all behaviors trong original object called `context`, thì chỉ cần lưu trữ tham chiếu đến state object tương ứng & ủy thác công việc cho nó 

![[oopp-177.png]]

- Tất cả state classes phải follow cùng interface để có thể chuyển đổi giữa state & context class chỉ works với state class thông qua interface này

- Structure này tương tự như **Strategy** pattern, nhưng có một điểm khác biệt chính
	- Ở State pattern, các states cụ thể có thể nhận biết lẫn nhau & chuyển đổi từ state này sang state khác
	- Ở Strategies thì hầu như không bao giờ biết về nhau

# Real-World Analogy

- The buttons & switches trong smartphone hoạt động khác nhau tùy thuộc vào state of the device:
	- Khi phone unlocked, pressing buttons dẫn đến việc thực hiện các chức năng khác nhau
	- Khi phone locked, pressing any buttons cũng dẫn đến màn hình mở khóa
	- Khi phone gần hết pin, pressing any button sẽ hiển thị màn hình sạc

# Structure

![[oop-178.png]]

- **Context** lưu trữ một tham chiếu đến concrete state objects & delegates tất cả công việc của state
	- Context communicates with state via state interface
	- The context expose một setter để truyền cho nó một new state object
	
- The **State** interface declares the state-specific methods
	- Những methods này sẽ có nghĩa có tất cả concrete states bởi vì không muốn một số states có những methods vô dụng không bao giờ được called
	
- **Concrete States** là class implement state interface
	- Cung cấp methods cụ thể để handle riêng cho state cụ thể
	- Để tránh duplication code giữa các state class này thì 





















