
![[oop-191.png]]

# Concept 

***Visitor is a behavioral design pattern that lets you separate algorithms from the objects on which they operate***

- Visitor là một mẫu thiết kế hành vi cho phép bạn tách các thuật toán khỏi các đối tượng mà chúng hoạt động


Ví dụ:
- Hãy tưởng tượng bạn đang ở một bảo tàng. Có rất nhiều loại hiện vật khác nhau: tranh, tượng, và di tích cổ. Mỗi loại hiện vật đều có những cách khám phá riêng. Ví dụ, bạn có thể chụp ảnh tranh, đo kích thước tượng, hoặc tìm hiểu thông tin về di tích cổ
	- **Hiện vật (Element)**: Các hiện vật trong bảo tàng như tranh, tượng, và di tích cổ.
	- **Hướng dẫn viên (Visitor)**: Người hướng dẫn viên sẽ thực hiện các hành động khác nhau như chụp ảnh, đo kích thước, hoặc tìm hiểu thông tin cho mỗi loại hiện vật.

# Problem

- Tưởng tượng rằng your team develops an app hoạt động với thông tin địa lý được structured như một biểu đồ khổng lồ
	- Mỗi node of the graph có thể represent a complex entity such as a city, cũng có thể chi tiết hơn như industries(ngành công nghiệp), khu vực tham quan, vv
	- Các nodes connected với nhau nếu có một road giữa các real object mà chúng represent
	- Under the hood(ngầm ở dưới code), mỗi node type is represented by class riêng của nó, trong khi mỗi specifict node là một object

![[oop-192.png]]

- At some point, bạn có một task implement exporting the graph into XML format
	- At first, the job có vẻ khá đơn giản
	- Bạn đã lên plan to add an export method to each node class & sau đó tận dụng recursion(đệ quy) to go over each node of the graph, executing the export method
	- Giải pháp đơn giản là: nhờ tính polymorphism(đa hình), bạn đã không coupling the code được called là export method to concrete classes of nodes
	
- Thật không may, the system architect refused to allow bạn alter existing node classes
	- Vì code đã already in production & để tránh rủi ro xảy ra các bugs 

![[oop-193.png]]

- Bên cạnh đó, một câu hỏi được đặt ra là liệu có hợp lý khi XML export code tồn tại trong mỗi node classes hay không ?
	- Mà primary job của node class này là work với dữ liệu về địa lý và XML export behavior trông hơi không liên quan lắm 
	
- Một lý do từ chối khác là: 
	- Rất có thể sau khi implement feature này, lại có một feature với format khác XML được sinh ra, ... và điều này force bạn phải sửa classes mong manh thêm lần nữa
	

# Solution

- The Visitor pattern suggest that you place the new behavior into a separate class called *visitor*, thay vì trying to intergrate vào existing classes
	- The original object phải thực hiện the behavior thì giờ đây được passed t one of the visitor's methods as an argument, cung cấp method access to all necessary data contained trong object
	
- Now, điều gì sẽ xảy ra nếu behavior can be executed trên objects of different classes ?
	- Ex: in our case with XML report, việc triển khai thực tế có thể hơi khác một chút giữa các node classes
	- Do vậy, visitor class không chỉ có một, mà là một tập hợp methods, mỗi method có thể lấy các arguments thuộc các loại khác nhau
- 